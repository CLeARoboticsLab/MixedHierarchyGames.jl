var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module","page":"API Reference","title":"Module","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Solvers","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#Solver-Helpers","page":"API Reference","title":"Solver Helpers","text":"","category":"section"},{"location":"api/#Linesearch-Methods","page":"API Reference","title":"Linesearch Methods","text":"","category":"section"},{"location":"api/#KKT-Construction","page":"API Reference","title":"KKT Construction","text":"","category":"section"},{"location":"api/#Problem-Setup","page":"API Reference","title":"Problem Setup","text":"","category":"section"},{"location":"api/#Graph-Utilities","page":"API Reference","title":"Graph Utilities","text":"","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"","category":"section"},{"location":"api/#MixedHierarchyGames","page":"API Reference","title":"MixedHierarchyGames","text":"MixedHierarchyGames\n\nA Julia package for solving mixed hierarchy (Stackelberg) trajectory games.\n\nProvides two solvers:\n\nQPSolver - For quadratic programming problems with linear dynamics\nNonlinearSolver - For general nonlinear problems\n\nBoth solvers implement the TrajectoryGamesBase.solve_trajectory_game! interface.\n\n\n\n\n\n","category":"module"},{"location":"api/#MixedHierarchyGames.QPSolver","page":"API Reference","title":"MixedHierarchyGames.QPSolver","text":"QPSolver\n\nSolver for quadratic programming hierarchy games (linear dynamics, quadratic costs).\n\nFields\n\nproblem::HierarchyProblem - The problem specification\nsolver_type::Symbol - Solver backend (:linear or :path)\nprecomputed::QPPrecomputed - Precomputed symbolic components (variables, KKT conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedHierarchyGames.NonlinearSolver","page":"API Reference","title":"MixedHierarchyGames.NonlinearSolver","text":"NonlinearSolver\n\nSolver for general nonlinear hierarchy games.\n\nUses iterative quasi-linear policy approximation with configurable line search.\n\nFields\n\nproblem::HierarchyProblem - The problem specification\nprecomputed::NamedTuple - Precomputed symbolic components from preoptimizenonlinearsolver\noptions::NamedTuple - Solver options (maxiters, tol, verbose, linesearchmethod, recomputepolicyinlinesearch, usesparse)\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedHierarchyGames.HierarchyGame","page":"API Reference","title":"MixedHierarchyGames.HierarchyGame","text":"HierarchyGame\n\nA trajectory game with hierarchical (Stackelberg) structure.\n\nFields\n\ngame::TrajectoryGame - The underlying trajectory game\nhierarchy_graph::SimpleDiGraph - DAG representing leader-follower relationships (edge i→j means player i is a leader of player j)\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedHierarchyGames.HierarchyProblem","page":"API Reference","title":"MixedHierarchyGames.HierarchyProblem","text":"HierarchyProblem\n\nLow-level problem specification for hierarchy games. Stores cost functions, constraints, and symbolic variables. Used by both QPSolver and NonlinearSolver.\n\nFields\n\nhierarchy_graph::SimpleDiGraph - DAG of leader-follower relationships\nJs::Dict - Cost functions per player: Jsi → scalar\ngs::Vector - Constraint functions per player: gsi → Vector\nprimal_dims::Vector{Int} - Decision variable dimension per player\nθs::Dict - Symbolic parameter variables per player\nstate_dim::Int - State dimension per player (for trajectory extraction)\ncontrol_dim::Int - Control dimension per player (for trajectory extraction)\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedHierarchyGames.QPPrecomputed","page":"API Reference","title":"MixedHierarchyGames.QPPrecomputed","text":"QPPrecomputed\n\nPrecomputed components for QPSolver, cached during construction for efficient repeated solves.\n\nType Parameters\n\nTV - Type of problem variables (from setupproblemvariables)\nTK - Type of KKT conditions result (from getqpkkt_conditions)\nTP<:AbstractDict - Type of stripped policy constraints (Dict)\nTM - Type of parametric MCP (ParametricMCP)\nTJ - Type of Jacobian buffer (sparse or dense matrix)\n\nFields\n\nvars::TV - Problem variables from setupproblemvariables\nkkt_result::TK - KKT conditions from getqpkkt_conditions\nπs_solve::TP - Stripped policy constraints for solving\nparametric_mcp::TM - Cached ParametricMCP for solving\nJ_buffer::TJ - Pre-allocated Jacobian buffer for solveqplinear\nF_buffer::Vector{Float64} - Pre-allocated residual buffer for solveqplinear\nz0_buffer::Vector{Float64} - Pre-allocated zero vector for solveqplinear\n\n\n\n\n\n","category":"type"},{"location":"api/#MixedHierarchyGames.solve","page":"API Reference","title":"MixedHierarchyGames.solve","text":"solve(solver::QPSolver, parameter_values::Dict; kwargs...)\n\nSolve the QP hierarchy game with given parameter values (typically initial states).\n\nUses precomputed symbolic KKT conditions for efficiency.\n\nArguments\n\nsolver::QPSolver - The QP solver with precomputed components\nparameter_values::Dict - Numerical values for parameters (e.g., initial states per player)\n\nKeyword Arguments\n\nverbose::Bool=false - Print debug info\niteration_limit::Int=100000 - Maximum iterations for PATH solver (only used with :path)\nproximal_perturbation::Float64=1e-2 - Proximal perturbation parameter (only used with :path)\nuse_basics::Bool=true - Use basic solution from PATH (only used with :path)\nuse_start::Bool=true - Use starting point from PATH (only used with :path)\n\nReturns\n\nJointStrategy containing OpenLoopStrategy for each player\n\n\n\n\n\nsolve(solver::NonlinearSolver, parameter_values::Dict; kwargs...)\n\nSolve the nonlinear hierarchy game with given parameter values (typically initial states).\n\nUses precomputed symbolic components for efficiency.\n\nArguments\n\nsolver::NonlinearSolver - The nonlinear solver with precomputed components\nparameter_values::Dict - Numerical values for parameters (e.g., initial states per player)\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector}=nothing - Warm start for the solver\nshow_progress::Union{Nothing, Bool}=nothing - Display iteration progress table\nAdditional options override solver.options\n\nReturns\n\nJointStrategy containing OpenLoopStrategy for each player\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.solve_raw","page":"API Reference","title":"MixedHierarchyGames.solve_raw","text":"solve_raw(solver::QPSolver, parameter_values::Dict; kwargs...)\n\nSolve and return raw solution vector (for debugging/analysis).\n\nKeyword Arguments\n\nverbose::Bool=false - Print debug info\niteration_limit::Int=100000 - Maximum iterations for PATH solver (only used with :path)\nproximal_perturbation::Float64=1e-2 - Proximal perturbation parameter (only used with :path)\nuse_basics::Bool=true - Use basic solution from PATH (only used with :path)\nuse_start::Bool=true - Use starting point from PATH (only used with :path)\n\nReturns\n\nNamed tuple with fields:\n\nsol::Vector{Float64} - Solution vector (concatenated player decision variables)\nstatus::Symbol - Solver status (:solved or :failed)\ninfo - PATH solver info (only for :path backend, nothing for :linear)\nvars - Symbolic variables from precomputation\n\n\n\n\n\nsolve_raw(solver::NonlinearSolver, parameter_values::Dict; kwargs...)\n\nSolve and return raw solution with convergence info (for debugging/analysis).\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector}=nothing - Warm start for the solver\nmax_iters::Int - Maximum iterations (default from solver.options)\ntol::Float64 - Convergence tolerance (default from solver.options)\nverbose::Bool - Print iteration info (default from solver.options)\nlinesearch_method::Symbol - Line search method (default from solver.options)\nrecompute_policy_in_linesearch::Bool - Recompute K matrices at each line search trial step (default from solver.options)\nshow_progress::Bool - Display iteration progress table (default from solver.options)\n\nReturns\n\nNamed tuple with fields:\n\nsol::Vector{Float64} - Solution vector (concatenated player decision variables)\nconverged::Bool - Whether solver converged to tolerance\niterations::Int - Number of iterations taken\nresidual::Float64 - Final KKT residual norm\nstatus::Symbol - Solver status:\n:solved - Converged successfully\n:solved_initial_point - Initial guess was already a solution\n:max_iters_reached - Did not converge within iteration limit\n:linear_solver_error - Newton step computation failed\n:line_search_failed - Armijo line search failed to find sufficient decrease\n:numerical_error - NaN or Inf encountered\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.solve_with_path","page":"API Reference","title":"MixedHierarchyGames.solve_with_path","text":"solve_with_path(parametric_mcp, θs::Dict, parameter_values::Dict; kwargs...)\n\nSolve KKT system using PATH solver via ParametricMCPs.jl with cached MCP.\n\nArguments\n\nparametric_mcp - Precomputed ParametricMCP from QPSolver construction\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical parameter values per player\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector}=nothing - Warm start\nverbose::Bool=false - Print solver output\niteration_limit::Int=100000 - Maximum iterations for PATH solver\nproximal_perturbation::Float64=1e-2 - Proximal perturbation parameter\nuse_basics::Bool=true - Use basic solution from PATH\nuse_start::Bool=true - Use starting point from PATH\n\nReturns\n\nTuple of:\n\nsol::Vector - Solution vector\nstatus::Symbol - Solver status (:solved, :failed, etc.)\ninfo - PATH solver info\n\n\n\n\n\nsolve_with_path(πs::Dict, variables::Vector, θs::Dict, parameter_values::Dict; kwargs...)\n\nSolve KKT system using PATH solver via ParametricMCPs.jl (builds MCP internally).\n\nArguments\n\nπs::Dict - KKT conditions per player\nvariables::Vector - All symbolic variables\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical parameter values per player\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector}=nothing - Warm start\nverbose::Bool=false - Print solver output\niteration_limit::Int=100000 - Maximum iterations for PATH solver\nproximal_perturbation::Float64=1e-2 - Proximal perturbation parameter\nuse_basics::Bool=true - Use basic solution from PATH\nuse_start::Bool=true - Use starting point from PATH\n\nReturns\n\nTuple of:\n\nsol::Vector - Solution vector\nstatus::Symbol - Solver status (:solved, :failed, etc.)\ninfo - PATH solver info\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.solve_qp_linear","page":"API Reference","title":"MixedHierarchyGames.solve_qp_linear","text":"solve_qp_linear(parametric_mcp, θs::Dict, parameter_values::Dict; kwargs...)\n\nSolve LQ game KKT system using direct linear solve with cached MCP.\n\nFor LQ games with only equality constraints, the KKT system is linear: Jz = -F where J is the Jacobian and F is the KKT residual.\n\nArguments\n\nparametric_mcp - Precomputed ParametricMCP from QPSolver construction\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical parameter values per player\n\nKeyword Arguments\n\nverbose::Bool=false - Print solver output\n\nReturns\n\nTuple of:\n\nsol::Vector - Solution vector\nstatus::Symbol - Solver status (:solved or :failed)\n\n\n\n\n\nsolve_qp_linear(πs::Dict, variables::Vector, θs::Dict, parameter_values::Dict; kwargs...)\n\nSolve LQ game KKT system using direct linear solve (builds MCP internally).\n\nFor LQ games with only equality constraints, the KKT system is linear: Jz = -F where J is the Jacobian and F is the KKT residual.\n\nArguments\n\nπs::Dict - KKT conditions per player\nvariables::Vector - All symbolic variables\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical parameter values per player\n\nKeyword Arguments\n\nverbose::Bool=false - Print solver output\n\nReturns\n\nTuple of:\n\nsol::Vector - Solution vector\nstatus::Symbol - Solver status (:solved or :failed)\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.qp_game_linsolve","page":"API Reference","title":"MixedHierarchyGames.qp_game_linsolve","text":"qp_game_linsolve(A, b; kwargs...)\n\nSolve linear system Ax = b for QP games.\n\nFor LQ games, the KKT system is linear so this directly solves for the solution.\n\nArguments\n\nA - System matrix (Jacobian of KKT conditions)\nb - Right-hand side\n\nReturns\n\nx::Vector - Solution vector\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.run_nonlinear_solver","page":"API Reference","title":"MixedHierarchyGames.run_nonlinear_solver","text":"run_nonlinear_solver(\n    precomputed::NamedTuple,\n    initial_states::Dict,\n    hierarchy_graph::SimpleDiGraph;\n    initial_guess::Union{Nothing, Vector{Float64}} = nothing,\n    max_iters::Int = 100,\n    tol::Float64 = 1e-6,\n    verbose::Bool = false,\n    linesearch_method::Symbol = :geometric,\n    recompute_policy_in_linesearch::Bool = true,\n    use_sparse::Bool = false,\n    show_progress::Bool = false,\n    to::TimerOutput = TimerOutput()\n)\n\nOrchestrates the Newton iteration loop for solving nonlinear hierarchy games.\n\nEach iteration: evaluate the KKT residual, check convergence, compute a Newton step via compute_newton_step, and select a step size via configurable line search. Convergence is checked by check_convergence.\n\nArguments\n\nprecomputed::NamedTuple - Precomputed symbolic components from preoptimize_nonlinear_solver\ninitial_states::Dict - Initial state for each player (keyed by player index)\nhierarchy_graph::SimpleDiGraph - Player hierarchy graph\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector{Float64}}=nothing - Starting point (zero-initialized if nothing)\nmax_iters::Int=100 - Maximum Newton iterations\ntol::Float64=1e-6 - Convergence tolerance on KKT residual norm\nverbose::Bool=false - Print per-iteration convergence info\nlinesearch_method::Symbol=:geometric - Line search method (:armijo, :geometric, or :constant)\nrecompute_policy_in_linesearch::Bool=true - Recompute K matrices at each line search trial step. Set to false for ~1.6x speedup (reuses K from current Newton iteration).\nuse_sparse::Bool=false - Use sparse LU for M\\N solve (beneficial for large problems)\nshow_progress::Bool=false - Display iteration progress table (iter, residual, step size, time)\nto::TimerOutput=TimerOutput() - Timer for profiling solver phases\n\nReturns\n\nNamed tuple (; sol, converged, iterations, residual, status):\n\nsol::Vector{Float64} - Solution vector\nconverged::Bool - Whether the solver reached the tolerance\niterations::Int - Number of iterations performed\nresidual::Float64 - Final KKT residual norm\nstatus::Symbol - One of :solved, :solved_initial_point, :max_iters_reached, :linear_solver_error, :line_search_failed, :numerical_error\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.extract_trajectories","page":"API Reference","title":"MixedHierarchyGames.extract_trajectories","text":"extract_trajectories(sol::Vector, dims::NamedTuple, T::Int, n_players::Int)\n\nExtract state and control trajectories from flattened solution vector.\n\nArguments\n\nsol::Vector - Flattened solution\ndims::NamedTuple - Dimension info per player\nT::Int - Time horizon\nn_players::Int - Number of players\n\nReturns\n\nxs::Dict{Int, Vector{Vector}} - State trajectories per player\nus::Dict{Int, Vector{Vector}} - Control trajectories per player\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.solution_to_joint_strategy","page":"API Reference","title":"MixedHierarchyGames.solution_to_joint_strategy","text":"solution_to_joint_strategy(xs::Dict, us::Dict, n_players::Int)\n\nConvert trajectory dictionaries to JointStrategy of OpenLoopStrategys.\n\nArguments\n\nxs::Dict - State trajectories per player\nus::Dict - Control trajectories per player\nn_players::Int - Number of players\n\nReturns\n\nJointStrategy over OpenLoopStrategys\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.split_solution_vector","page":"API Reference","title":"MixedHierarchyGames.split_solution_vector","text":"split_solution_vector(sol::AbstractVector, block_sizes::Vector{Int})\n\nSplit a flat vector into blocks using BlockArrays.\n\nReturns an iterable of blocks where each block is a view into the original vector. Uses PseudoBlockVector for a zero-copy view.\n\nArguments\n\nsol - Flat vector to split\nblock_sizes - Size of each block\n\nExample\n\nsol = [1.0, 2.0, 3.0, 4.0, 5.0]\nplayer_blocks = split_solution_vector(sol, [2, 3])\n# blocks: [[1.0, 2.0], [3.0, 4.0, 5.0]]\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.check_convergence","page":"API Reference","title":"MixedHierarchyGames.check_convergence","text":"check_convergence(residual, tol; verbose=false, iteration=nothing)\n\nCheck whether the solver has converged based on the KKT residual norm.\n\nReturns a named tuple (converged, status) where:\n\nconverged::Bool - whether the residual is below tolerance\nstatus::Symbol - :solved, :not_converged, or :numerical_error\n\nArguments\n\nresidual::Real - Current KKT residual norm\ntol::Real - Convergence tolerance\n\nKeyword Arguments\n\nverbose::Bool=false - Print convergence info\niteration::Union{Nothing,Int}=nothing - Current iteration number (for verbose output)\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.compute_newton_step","page":"API Reference","title":"MixedHierarchyGames.compute_newton_step","text":"compute_newton_step(linsolver, jacobian, neg_residual)\n\nSolve the Newton step linear system jacobian * δz = neg_residual.\n\nUses the provided LinearSolve solver instance for the factorization and solve. Handles singular matrix errors gracefully by returning success=false.\n\nArguments\n\nlinsolver - Initialized LinearSolve solver (mutated in place)\njacobian - Jacobian matrix (∇F)\nneg_residual - Negative residual vector (-F)\n\nReturns\n\nNamed tuple (step, success) where:\n\nstep::Vector - Newton step direction δz (undefined if success=false)\nsuccess::Bool - Whether the linear solve succeeded\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.perform_linesearch","page":"API Reference","title":"MixedHierarchyGames.perform_linesearch","text":"perform_linesearch(residual_norm_fn, z_est, δz, current_residual_norm; use_armijo=true)\n\nPerform backtracking line search to select step size for Newton update.\n\nWhen use_armijo=true, backtracks from α=1.0 by halving until the trial point has a smaller residual norm than the current point, or max iterations are reached. When use_armijo=false, returns α=1.0 (full Newton step).\n\nArguments\n\nresidual_norm_fn - Function z_trial -> Float64 returning residual norm at trial point\nz_est::Vector - Current iterate\nδz::Vector - Newton step direction\ncurrent_residual_norm::Float64 - Residual norm at current iterate\n\nKeyword Arguments\n\nuse_armijo::Bool=true - Whether to perform backtracking line search\n\nReturns\n\nα::Float64 - Selected step size\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.armijo_backtracking","page":"API Reference","title":"MixedHierarchyGames.armijo_backtracking","text":"armijo_backtracking(f, x, d, alpha_init; c1=1e-4, rho=0.5, max_iters=20)\n\nArmijo backtracking line search for step size selection.\n\nUses the merit function ϕ(x) = ||f(x)||² and checks the sufficient decrease condition:\n\nϕ(x + α*d) ≤ ϕ(x) + c1 * α * ∇ϕ'*d\n\nwhere for Newton-like methods ∇ϕ'd ≈ -2||f(x)||².\n\nArguments\n\nf::Function - Residual function evaluating at a point, returns a vector\nx::Vector - Current point\nd::Vector - Search direction (typically the Newton step)\nalpha_init::Float64 - Initial step size\n\nKeyword Arguments\n\nc1::Float64=1e-4 - Sufficient decrease parameter (Armijo constant)\nrho::Float64=0.5 - Step size reduction factor per backtracking iteration\nmax_iters::Int=20 - Maximum number of backtracking iterations\n\nReturns\n\nα::Float64 - Selected step size, or 0.0 if no sufficient decrease found\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.geometric_reduction","page":"API Reference","title":"MixedHierarchyGames.geometric_reduction","text":"geometric_reduction(f, x, d, alpha_init; rho=0.5, max_iters=20)\n\nGeometric step-size reduction line search.\n\nReduces the step size by a fixed factor rho each iteration until the merit function ϕ(x) = ||f(x)||² strictly decreases:\n\nϕ(x + α*d) < ϕ(x)\n\nThis is a simpler alternative to armijo_backtracking — it requires only strict decrease rather than sufficient decrease, and has no Armijo constant c1.\n\nArguments\n\nf::Function - Residual function evaluating at a point, returns a vector\nx::Vector - Current point\nd::Vector - Search direction (typically the Newton step)\nalpha_init::Float64 - Initial step size\n\nKeyword Arguments\n\nrho::Float64=0.5 - Step size reduction factor per iteration\nmax_iters::Int=20 - Maximum number of reduction iterations\n\nReturns\n\nα::Float64 - Selected step size, or 0.0 if no decrease found\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.constant_step","page":"API Reference","title":"MixedHierarchyGames.constant_step","text":"constant_step(alpha)\n\nCreate a constant step-size line search that always returns alpha.\n\nReturns a closure with the same interface as other line search methods (f, x, d, alpha_init) -> α, but ignores all arguments and returns the fixed step size.\n\nUseful as a baseline or when the appropriate step size is known a priori.\n\nArguments\n\nalpha::Float64 - The fixed step size to return\n\nReturns\n\nA function (f, x, d, alpha_init) -> alpha that always returns the fixed step size\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.get_qp_kkt_conditions","page":"API Reference","title":"MixedHierarchyGames.get_qp_kkt_conditions","text":"get_qp_kkt_conditions(\n    G::SimpleDiGraph,\n    Js::Dict,\n    zs,\n    λs,\n    μs::Dict,\n    gs,\n    ws::Dict,\n    ys::Dict,\n    ws_z_indices::Dict;\n    θ = nothing,\n    verbose::Bool = false\n)\n\nConstruct KKT conditions for all players in reverse topological order.\n\nHandles both leaf and non-leaf players differently:\n\nLeaf players: Standard KKT (stationarity + constraints)\nNon-leaf players: KKT with policy constraints from followers, stored as BlockVector via mortar to preserve the interleaved block structure\n\nArguments\n\nG::SimpleDiGraph - DAG of leader-follower relationships\nJs::Dict{Int, Function} - Cost function for each player: Jsi → scalar\nzs - Decision variables per player (Dict or Vector)\nλs - Lagrange multipliers per player (Dict or Vector)\nμs::Dict{Tuple{Int,Int}, Any} - Policy constraint multipliers for (leader, follower) pairs\ngs - Constraint functions per player: gsi → Vector\nws::Dict - Remaining variables (for policy constraints)\nys::Dict - Information variables (leader decisions)\nws_z_indices::Dict - Index mapping: wszindices[i][j] gives range where zs[j] appears in ws[i]\nθ - Parameter variables (optional)\nverbose::Bool - Print debug info\n\nReturns\n\nNamed tuple containing:\n\nπs::Dict - KKT conditions per player (BlockVector for leaders, Vector for leaves)\nMs::Dict - M matrices for followers (from Mw + Ny = 0)\nNs::Dict - N matrices for followers\nKs::Dict - Policy matrices K = M \\ N\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.strip_policy_constraints","page":"API Reference","title":"MixedHierarchyGames.strip_policy_constraints","text":"strip_policy_constraints(πs::Dict, hierarchy_graph::SimpleDiGraph, zs::Dict, gs)\n\nRemove policy constraint rows from KKT conditions, keeping only stationarity + constraints.\n\nUsed for solving the reduced KKT system.\n\nArguments\n\nπs::Dict - Full KKT conditions per player\nhierarchy_graph::SimpleDiGraph - Hierarchy graph\nzs::Dict - Decision variables per player\ngs - Constraint functions per player\n\nReturns\n\nπs_stripped::Dict - KKT conditions without policy constraint rows\n\nNotes\n\nThe KKT conditions have an interleaved structure for leaders:\n\n[grad_self | grad_f1 | policy_f1 | grad_f2 | policy_f2 | ... | own_constraints]\n\nWhen πs[ii] is a BlockVector (from get_qp_kkt_conditions), blocks are accessed directly. For plain vectors (from the nonlinear solver), block sizes are computed and split_solution_vector is used. In both cases, policy blocks at indices 3, 5, 7, ... are removed.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.setup_approximate_kkt_solver","page":"API Reference","title":"MixedHierarchyGames.setup_approximate_kkt_solver","text":"setup_approximate_kkt_solver(\n    G::SimpleDiGraph,\n    Js::Dict,\n    zs::Dict,\n    λs::Dict,\n    μs::Dict,\n    gs::Vector,\n    ws::Dict,\n    ys::Dict,\n    θs::Dict,\n    all_variables::Vector,\n    backend;\n    verbose::Bool = false\n)\n\nPrecompute symbolic KKT conditions and M/N matrix evaluation functions for nonlinear solver.\n\nUnlike QP KKT construction which computes K = M \\ N symbolically, this creates compiled functions for evaluating M and N numerically, avoiding expression blowup.\n\nArguments\n\nG::SimpleDiGraph - Hierarchy graph\nJs::Dict - Cost functions per player\nzs::Dict - Decision variables per player\nλs::Dict - Lagrange multipliers per player\nμs::Dict - Policy constraint multipliers\ngs::Vector - Constraint functions per player\nws::Dict - Remaining variables (policy output)\nys::Dict - Information variables (policy input)\nθs::Dict - Parameter variables per player\nall_variables::Vector - All symbolic variables\nbackend - SymbolicTracingUtils backend\n\nKeyword Arguments\n\nverbose::Bool=false - Print debug info\ncse::Bool=false - Enable Common Subexpression Elimination during symbolic compilation. CSE can dramatically reduce construction time and memory for problems with redundant symbolic structure (e.g., quadratic costs), but may slightly increase per-solve runtime. Recommended only when construction time is a bottleneck and you can tolerate slightly slower solve times. Default: false for maximum runtime performance.\n\nReturns\n\nTuple of:\n\nall_augmented_variables::Vector - Variables including K matrix symbols\nsetup_info::NamedTuple - Contains:\ngraph - Hierarchy graph\nπs - KKT conditions per player\nK_syms - Symbolic K matrices per player\nM_fns - Compiled M matrix evaluation functions\nN_fns - Compiled N matrix evaluation functions\nπ_sizes - KKT condition sizes per player\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.preoptimize_nonlinear_solver","page":"API Reference","title":"MixedHierarchyGames.preoptimize_nonlinear_solver","text":"preoptimize_nonlinear_solver(\n    hierarchy_graph::SimpleDiGraph,\n    Js::Dict,\n    gs::Vector,\n    primal_dims::Vector{Int},\n    θs::Dict;\n    state_dim::Int = 2,\n    control_dim::Int = 2,\n    backend = default_backend(),\n    verbose::Bool = false\n)\n\nPrecompute all symbolic components for nonlinear solver.\n\nThis is called once before solving to build all the symbolic expressions and compile them to efficient numerical functions.\n\nArguments\n\nhierarchy_graph::SimpleDiGraph - Hierarchy graph\nJs::Dict - Cost functions per player\ngs::Vector - Constraint functions per player\nprimal_dims::Vector{Int} - Primal variable dimension per player\nθs::Dict - Parameter variables per player\n\nKeyword Arguments\n\nstate_dim::Int=2 - State dimension (for trajectory extraction)\ncontrol_dim::Int=2 - Control dimension (for trajectory extraction)\nbackend - SymbolicTracingUtils backend\nverbose::Bool=false - Print debug info\ncse::Bool=false - Enable Common Subexpression Elimination during symbolic compilation. CSE can dramatically reduce construction time and memory for problems with redundant symbolic structure (e.g., quadratic costs), but may slightly increase per-solve runtime. Recommended only when construction time is a bottleneck and you can tolerate slightly slower solve times. Default: false for maximum runtime performance.\n\nReturns\n\nNamed tuple containing:\n\nproblem_vars - Problem variables (zs, λs, μs, ws, ys, all_variables)\nsetup_info - Setup info from setupapproximatekkt_solver\nmcp_obj - ParametricMCP object for residual evaluation\nlinsolver - LinearSolve problem for iterative solving\nall_variables - All symbolic variables\nall_augmented_variables - Variables including K matrices\nF_sym - Symbolic KKT residual vector\nπ_sizes_trimmed - Trimmed KKT sizes per player\nstate_dim - State dimension\ncontrol_dim - Control dimension\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.compute_K_evals","page":"API Reference","title":"MixedHierarchyGames.compute_K_evals","text":"compute_K_evals(z_current, problem_vars, setup_info; use_sparse=false)\n\nEvaluate K (policy) matrices numerically in reverse topological order.\n\nNote: This function is NOT thread-safe. The precomputed Mfns and Nfns contain shared result buffers that would cause data races if called concurrently. For multi-threaded use, each thread needs its own solver instance. See Phase 6 for planned thread-safety improvements.\n\nArguments\n\nz_current::Vector - Current solution estimate\nproblem_vars::NamedTuple - Problem variables (from setupproblemvariables)\nsetup_info::NamedTuple - Setup info (from setupapproximatekkt_solver)\n\nKeyword Arguments\n\nuse_sparse::Bool=false - If true, use sparse LU factorization for M\\N solve. Beneficial for large M matrices (>100 rows) with structural sparsity from the KKT system. For small matrices, dense solve is faster due to sparse overhead.\n\nReturns\n\nTuple of:\n\nall_K_vec::Vector - Concatenated K matrix values for all players\ninfo::NamedTuple - Contains Mevals, Nevals, K_evals, status\nstatus is :ok or :singular_matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.setup_problem_variables","page":"API Reference","title":"MixedHierarchyGames.setup_problem_variables","text":"setup_problem_variables(\n    graph::SimpleDiGraph,\n    primal_dims::Vector{Int},\n    gs::Vector;\n    backend=default_backend()\n)\n\nConstruct all symbolic variables needed for the KKT system.\n\nArguments\n\ngraph::SimpleDiGraph - DAG of leader-follower relationships\nprimal_dims::Vector{Int} - Decision variable dimension for each player\ngs::Vector - Constraint functions for each player (gsi returns constraints)\nbackend - SymbolicTracingUtils backend (default: SymbolicsBackend)\n\nReturns\n\nNamed tuple containing:\n\nzs::Dict - Decision variables per player\nλs::Dict - Lagrange multipliers for constraints per player\nμs::Dict - Policy constraint multipliers (leader, follower) pairs\nys::Dict - Information vectors (leader decisions visible to each player)\nws::Dict - Remaining variables for policy constraints\nws_z_indices::Dict - Index mapping: wszindices[i][j] gives range where zs[j] appears in ws[i]\nall_variables::Vector - Flattened vector of all variables\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.setup_problem_parameter_variables","page":"API Reference","title":"MixedHierarchyGames.setup_problem_parameter_variables","text":"setup_problem_parameter_variables(num_params_per_player::Vector{Int}; backend=default_backend())\n\nCreate symbolic parameter variables (θ) for each player's initial state.\n\nArguments\n\nnum_params_per_player::Vector{Int} - Number of parameters for each player\nbackend - SymbolicTracingUtils backend (default: SymbolicsBackend)\n\nReturns\n\nθs::Dict{Int, Vector} - Dictionary mapping player index to their parameter variables\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.make_symbolic_vector","page":"API Reference","title":"MixedHierarchyGames.make_symbolic_vector","text":"make_symbolic_vector(name::Symbol, player::Int, dim::Int; backend=default_backend())\n\nCreate a vector of dim symbolic variables for a player.\n\nValid names: (:z, :λ, :θ, :u, :x, :M, :N, :K)\n\n\n\n\n\nmake_symbolic_vector(name::Symbol, leader::Int, follower::Int, dim::Int; backend=default_backend())\n\nCreate a vector of dim symbolic variables for a leader-follower pair.\n\nValid names: (:μ,)\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.make_symbolic_matrix","page":"API Reference","title":"MixedHierarchyGames.make_symbolic_matrix","text":"make_symbolic_matrix(name::Symbol, player::Int, rows::Int, cols::Int; backend=default_backend())\n\nCreate a rows × cols matrix of symbolic variables for a player.\n\nValid names: (:z, :λ, :θ, :u, :x, :M, :N, :K)\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.make_symbol","page":"API Reference","title":"MixedHierarchyGames.make_symbol","text":"make_symbol(name::Symbol, player::Int)\n\nCreate a symbol for a player variable. Valid names: (:z, :λ, :θ, :u, :x, :M, :N, :K)\n\nReturns Symbol(\"name^player\"), e.g., Symbol(\"z^1\").\n\n\n\n\n\nmake_symbol(name::Symbol, leader::Int, follower::Int)\n\nCreate a symbol for a leader-follower pair variable. Valid names: (:μ,)\n\nReturns Symbol(\"name^(leader-follower)\"), e.g., Symbol(\"μ^(1-2)\").\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.default_backend","page":"API Reference","title":"MixedHierarchyGames.default_backend","text":"Return a fresh SymbolicsBackend instance for symbolic tracing.\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.is_root","page":"API Reference","title":"MixedHierarchyGames.is_root","text":"is_root(G::SimpleDiGraph, node::Int)\n\nCheck if node has no incoming edges (i.e., is a root/top-level leader).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.is_leaf","page":"API Reference","title":"MixedHierarchyGames.is_leaf","text":"is_leaf(G::SimpleDiGraph, node::Int)\n\nCheck if node has no outgoing edges (i.e., is a leaf/pure follower).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.has_leader","page":"API Reference","title":"MixedHierarchyGames.has_leader","text":"has_leader(G::SimpleDiGraph, node::Int)\n\nCheck if node has any incoming edges (i.e., has a leader).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.get_roots","page":"API Reference","title":"MixedHierarchyGames.get_roots","text":"get_roots(G::SimpleDiGraph)\n\nReturn all root nodes (nodes with no incoming edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.get_all_leaders","page":"API Reference","title":"MixedHierarchyGames.get_all_leaders","text":"get_all_leaders(G::SimpleDiGraph, node::Int)\n\nReturn all ancestors of node up to root (all direct and indirect leaders).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.get_all_followers","page":"API Reference","title":"MixedHierarchyGames.get_all_followers","text":"get_all_followers(G::SimpleDiGraph, node::Int)\n\nReturn all descendants of node (entire subtree of followers).\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.evaluate_kkt_residuals","page":"API Reference","title":"MixedHierarchyGames.evaluate_kkt_residuals","text":"evaluate_kkt_residuals(\n    πs::Dict,\n    all_variables::Vector,\n    sol::Vector,\n    θs::Dict,\n    parameter_values::Dict;\n    tol::Float64 = 1e-6,\n    verbose::Bool = false,\n    should_enforce::Bool = false\n)\n\nEvaluate symbolic KKT conditions at the numerical solution.\n\nSubstitutes numerical values and computes residual norms to verify solution validity.\n\nArguments\n\nπs::Dict{Int, Any} - Symbolic KKT conditions per player\nall_variables::Vector - All symbolic decision variables\nsol::Vector - Numerical solution vector\nθs::Dict{Int, Any} - Symbolic parameter variables per player\nparameter_values::Dict{Int, Vector} - Numerical values for parameters\n\nKeyword Arguments\n\ntol::Float64=1e-6 - Tolerance for checking satisfaction\nverbose::Bool=false - Print residual details\nshould_enforce::Bool=false - Assert if conditions not satisfied\n\nReturns\n\nπ_eval::Vector{Float64} - Evaluated residual vector\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames.verify_kkt_solution","page":"API Reference","title":"MixedHierarchyGames.verify_kkt_solution","text":"verify_kkt_solution(solver, sol::Vector, θs::Dict, parameter_values::Dict; kwargs...)\n\nVerify that a solution satisfies the KKT conditions. The solver must have precomputed.setup_info.πs and related fields (NonlinearSolver).\n\nThis is a convenience wrapper that extracts the necessary data from the solver and calls evaluate_kkt_residuals.\n\nNote: For NonlinearSolver, this function evaluates the KKT conditions with the actual K (policy derivative) values computed at the solution. The residuals should be small for a properly converged solution.\n\nArguments\n\nsolver - The solver used to find the solution (NonlinearSolver)\nsol::Vector - The solution vector (from result.sol)\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical values for parameters\n\nKeyword Arguments\n\ntol::Float64=1e-6 - Tolerance for checking satisfaction\nverbose::Bool=false - Print residual details\nshould_enforce::Bool=false - Assert if conditions not satisfied\n\nReturns\n\nπ_eval::Vector{Float64} - Evaluated residual vector\n\nExample\n\nresult = solve_raw(solver, parameter_values)\nresiduals = verify_kkt_solution(solver, result.sol, θs, parameter_values; verbose=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#MixedHierarchyGames._build_augmented_z_est-NTuple{6, Any}","page":"API Reference","title":"MixedHierarchyGames._build_augmented_z_est","text":"_build_augmented_z_est(ii, z_est, K_evals, graph, follower_cache, buffer_cache)\n\nBuild augmented z vector for player ii including follower K evaluations.\n\nArguments\n\nii::Int - Player index\nz_est::Vector - Current z estimate\nK_evals::Dict - Numerical K matrices per player\ngraph::SimpleDiGraph - Hierarchy graph\nfollower_cache::Dict - Cache for follower lists\nbuffer_cache::Dict - Cache for augmented buffers\n\nReturns\n\naugmented_z::Vector - z_est augmented with follower K values\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._build_extractor-Tuple{UnitRange{Int64}, Int64}","page":"API Reference","title":"MixedHierarchyGames._build_extractor","text":"_build_extractor(indices::UnitRange{Int}, total_len::Int)\n\nBuild a sparse extraction matrix for policy constraints.\n\nUsed to extract the follower's decision variables (zs[j]) from the full policy response (Ks[j] * ys[j]). The indices come from wszindices, which explicitly tracks where each player's variables appear in the ws vector.\n\nExample\n\nIf ws[j] = [zs[j], zs[other], λs[j], ...] and zs[j] has dimension 3, then:\n\nindices = 1:3 (from wszindices[j][j])\nextractor * (Ks[j] * ys[j]) gives the zs[j] portion of the policy response\n\nReturns a sparse matrix E such that E * v extracts v[indices].\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._build_parametric_mcp-Tuple{Dict, Vector, Dict}","page":"API Reference","title":"MixedHierarchyGames._build_parametric_mcp","text":"_build_parametric_mcp(πs::Dict, variables::Vector, θs::Dict)\n\nBuild a ParametricMCP from KKT conditions during QPSolver construction.\n\nThe MCP is cached in precomputed to avoid rebuilding it on each solve() call. This provides significant performance benefits for repeated solves with different parameter values (e.g., different initial states).\n\nNote: We use ParametricMCPs primarily for its compiled f! and jacobian_z! functions. The bounds infrastructure (-∞ to ∞) is unused since we only support equality constraints. See task MixedHierarchyGames.jl-s6u for potential future optimization.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._construct_augmented_variables-NTuple{4, Any}","page":"API Reference","title":"MixedHierarchyGames._construct_augmented_variables","text":"_construct_augmented_variables(ii, all_variables, K_syms, G)\n\nBuild augmented variable list for player ii including follower K matrices.\n\nFor computing M and N that depend on follower policies, we need to include symbolic K matrices in the variable list.\n\nArguments\n\nii::Int - Player index\nall_variables::Vector - Base symbolic variables\nK_syms::Dict - Symbolic K matrices per player\nG::SimpleDiGraph - Hierarchy graph\n\nReturns\n\naugmented::Vector - Variables including follower K matrix entries\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._extract_joint_strategy-Tuple{AbstractVector, Vector{Int64}, Int64, Int64}","page":"API Reference","title":"MixedHierarchyGames._extract_joint_strategy","text":"_extract_joint_strategy(sol, primal_dims, state_dim, control_dim)\n\nExtract per-player trajectories from solution vector and build JointStrategy. Shared helper used by both QPSolver and NonlinearSolver.\n\nThe solution vector may contain dual variables (λ, μ) after the primal variables. Only the first sum(primal_dims) elements are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._run_qp_solver-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Dict, Vector, Vector{Int64}, Dict, Dict}","page":"API Reference","title":"MixedHierarchyGames._run_qp_solver","text":"_run_qp_solver(\n    hierarchy_graph::SimpleDiGraph,\n    Js::Dict,\n    gs::Vector,\n    primal_dims::Vector{Int},\n    θs::Dict,\n    parameter_values::Dict;\n    solver::Symbol = :linear,\n    verbose::Bool = false\n)\n\nInternal QP solver that orchestrates KKT construction and solving.\n\nNote: This is an internal function. Users should prefer QPSolver + solve() for better performance (the MCP is cached in QPSolver.precomputed.parametric_mcp). This function rebuilds the MCP on every call, which is inefficient for repeated solves.\n\nArguments\n\nhierarchy_graph::SimpleDiGraph - Hierarchy graph\nJs::Dict - Cost functions per player: Jsi → scalar\ngs::Vector - Constraint functions per player: gsi → Vector\nprimal_dims::Vector{Int} - Primal variable dimension per player\nθs::Dict - Symbolic parameter variables per player\nparameter_values::Dict - Numerical parameter values per player\n\nKeyword Arguments\n\nsolver::Symbol=:linear - Solver to use: :linear (direct) or :path (MCP)\nverbose::Bool=false - Print debug info\n\nReturns\n\nNamed tuple containing:\n\nsol::Vector - Solution vector\nstatus - Solver status\ninfo - Additional solver info\nvars - Problem variables (zs, λs, μs, etc.)\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._solve_K-Tuple{Matrix{Float64}, Matrix{Float64}, Int64}","page":"API Reference","title":"MixedHierarchyGames._solve_K","text":"_solve_K(M, N, player_idx; use_sparse=false)\n\nSolve K = M \\ N with protection against singular or ill-conditioned M matrices.\n\nWhen use_sparse=true, converts M to sparse format before solving, which can be beneficial for large M matrices (>100 rows) with structural sparsity from the KKT system.\n\nReturns a NaN-filled matrix (same size as expected K) if M is singular or severely ill-conditioned, with a warning.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._validate_constraint_functions-Tuple{Vector, Dict}","page":"API Reference","title":"MixedHierarchyGames._validate_constraint_functions","text":"_validate_constraint_functions(gs::Vector, zs::Dict)\n\nValidate that constraint functions have correct signatures, return Vectors, and only depend on the player's own decision variables (decoupled constraints).\n\nCalled during problem setup to catch errors early with clear messages.\n\nArguments\n\ngs::Vector - Constraint functions per player: gsi → Vector\nzs::Dict - Decision variables per player (used to test function signatures)\n\nThrows\n\nArgumentError if gs[i] has wrong signature, doesn't return AbstractVector, or contains variables from other players (coupled constraint)\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._validate_parameter_values-Tuple{Dict, Dict}","page":"API Reference","title":"MixedHierarchyGames._validate_parameter_values","text":"_validate_parameter_values(parameter_values::Dict, θs::Dict)\n\nValidate parameter_values against expected θs structure. Throws ArgumentError on mismatch.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._validate_solver_inputs-Tuple{Graphs.SimpleGraphs.SimpleDiGraph, Dict, Vector, Vector{Int64}, Dict}","page":"API Reference","title":"MixedHierarchyGames._validate_solver_inputs","text":"_validate_solver_inputs(hierarchy_graph, Js, gs, primal_dims, θs)\n\nValidate inputs for solver constructors. Throws ArgumentError on invalid input. Used by both QPSolver and NonlinearSolver.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames._verify_linear_system-Tuple{Any, Int64, Dict}","page":"API Reference","title":"MixedHierarchyGames._verify_linear_system","text":"_verify_linear_system(mcp, n::Int, θs::Dict)\n\nVerify that the KKT system is affine (constant Jacobian) as required for QP/LQ games.\n\nQPSolver assumes the KKT system F(z) = 0 is affine in z, i.e., F(z) = Jz + b where J is constant. This allows direct linear solve: z = -J⁻¹b. If the system is nonlinear, the linear solve will produce incorrect results.\n\nThis check evaluates the Jacobian at two random points during construction. If they differ, a warning is issued. The check runs once at construction time, not at solve time.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames.flatten_trajectory-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Vector{T}, 1}}} where T","page":"API Reference","title":"MixedHierarchyGames.flatten_trajectory","text":"flatten_trajectory(xs::Vector{Vector{T}}, us::Vector{Vector{T}}) where T\n\nFlatten state and control trajectories into a single vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#MixedHierarchyGames.ordered_player_indices-Tuple{Dict}","page":"API Reference","title":"MixedHierarchyGames.ordered_player_indices","text":"ordered_player_indices(d::Dict)\n\nReturn the keys of d as a sorted vector, providing a canonical player ordering.\n\nThis is a convenience wrapper around sort(collect(keys(d))) used throughout the codebase to iterate over player-indexed dictionaries in a deterministic order.\n\n\n\n\n\n","category":"method"},{"location":"api/#TrajectoryGamesBase.solve_trajectory_game!-Tuple{NonlinearSolver, HierarchyGame, Any}","page":"API Reference","title":"TrajectoryGamesBase.solve_trajectory_game!","text":"TrajectoryGamesBase.solve_trajectory_game!(\n    solver::NonlinearSolver,\n    game::HierarchyGame,\n    initial_state;\n    kwargs...\n)\n\nSolve a nonlinear hierarchy game.\n\nArguments\n\nsolver::NonlinearSolver - The nonlinear solver instance\ngame::HierarchyGame - The hierarchy game to solve\ninitial_state - Initial state per player (Dict{Int, Vector} or Vector of Vectors)\n\nKeyword Arguments\n\ninitial_guess::Union{Nothing, Vector}=nothing - Warm start\nverbose::Bool=false - Print iteration info\n\nReturns\n\nJointStrategy over OpenLoopStrategys for each player\n\n\n\n\n\n","category":"method"},{"location":"api/#TrajectoryGamesBase.solve_trajectory_game!-Tuple{QPSolver, HierarchyGame, Any}","page":"API Reference","title":"TrajectoryGamesBase.solve_trajectory_game!","text":"TrajectoryGamesBase.solve_trajectory_game!(\n    solver::QPSolver,\n    game::HierarchyGame,\n    initial_state;\n    kwargs...\n)\n\nSolve a QP (linear-quadratic) hierarchy game.\n\nArguments\n\nsolver::QPSolver - The QP solver instance\ngame::HierarchyGame - The hierarchy game to solve\ninitial_state - Initial state per player (Dict{Int, Vector} or Vector of Vectors)\n\nKeyword Arguments\n\nverbose::Bool=false - Print debug info\n\nReturns\n\nJointStrategy containing OpenLoopStrategy for each player\n\n\n\n\n\n","category":"method"},{"location":"#MixedHierarchyGames.jl","page":"Home","title":"MixedHierarchyGames.jl","text":"A Julia package for solving mixed hierarchy (Stackelberg) trajectory games.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"MixedHierarchyGames.jl provides solvers for trajectory games with arbitrary leader-follower hierarchies defined by directed acyclic graphs (DAGs). The package implements the TrajectoryGamesBase.jl interface, though the solver is more general and can be used for general equality-constrained games.\n\nBased on: H. Khan, D. H. Lee, J. Li, T. Qiu, C. Ellis, J. Milzman, W. Suttle, and D. Fridovich-Keil, \"Efficiently Solving Mixed-Hierarchy Games with Quasi-Policy Approximations,\" 2026.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Flexible hierarchy structures: Supports arbitrary DAG-based leader-follower relationships (pure Stackelberg, Nash, or mixed)\nQP Solver: For linear-quadratic games with equality constraints\nNonlinear Solver: For general nonlinear games using iterative quasi-linear policy approximation\nTrajectoryGamesBase integration: Compatible with the TrajectoryGamesBase.jl ecosystem","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/CLeARoboticsLab/MixedHierarchyGames.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using MixedHierarchyGames\nusing Graphs: SimpleDiGraph, add_edge!\nusing Symbolics: @variables\n\n# Define a 2-player Stackelberg game: Player 1 leads Player 2\nG = SimpleDiGraph(2)\nadd_edge!(G, 1, 2)\n\n# Problem dimensions\nstate_dim = 2\ncontrol_dim = 1\nT = 3\nprimal_dims = [(state_dim + control_dim) * T, (state_dim + control_dim) * T]\n\n# Symbolic parameters\n@variables θ1[1:state_dim] θ2[1:state_dim]\nθs = Dict(1 => collect(θ1), 2 => collect(θ2))\n\n# Constraints and costs\ngs = [z -> z[1:state_dim] - collect(θ1), z -> z[1:state_dim] - collect(θ2)]\nJs = Dict(\n    1 => (z1, z2; θ=nothing) -> sum(z1.^2),\n    2 => (z1, z2; θ=nothing) -> sum(z2.^2),\n)\n\n# Create solver and solve\nsolver = QPSolver(G, Js, gs, primal_dims, θs, state_dim, control_dim)\nstrategy = solve(solver, Dict(1 => [1.0, 0.0], 2 => [0.0, 1.0]))\n\nSee the API Reference for detailed documentation of all exported functions and types.","category":"section"}]
}
